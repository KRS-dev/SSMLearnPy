from sklearn.preprocessing import PolynomialFeatures
import numpy as np


class PolynomialFeaturesWithPattern(PolynomialFeatures):
    def __init__(self, degree=2, interaction_only=False, include_bias=True, structure=None):
        super().__init__(degree=degree, interaction_only=interaction_only, include_bias=include_bias)
        self.structure = structure

    def fit(self, X, y=None):
        super().fit(X, y)
        return self
    def transform(self, X, y=None):
        transformed = super().transform(X)
        return transformed[:, self.structure]
    
    def fit_transform(self, X, y=None):
        super().fit_transform(X, y)
        return super().transform(X)[:, self.structure]


def complex_polynomial_features(y, degree = 3, skip_linear = False, structure = None, include_bias = False):
    """
    This is a hack because PolynomialFeatures does not support complex data.

    Parameters:
        y: (n_features, n_samples)
        degree: int
        skip_linear: bool
        structure: (n_features, n_polynomial_terms) boolean matrix. If structure[i,j] = True, then we include a term of the form y[i]**powers[i,j] in the polynomial features
            if structure is None, we include all terms as generated by PolynomialFeatures

    Returns:
        (n_polynomial_terms, n_samples): array of polynomial features of y
    """
    size = y.shape[0]
    p = PolynomialFeatures(degree=degree,
                            include_bias=include_bias).fit(np.ones((1, size))) 
    powers = p.powers_.T
    if skip_linear and not include_bias:
        powers = powers[:, size:] 
    if skip_linear and include_bias:
        powers = powers[:, size+1:] # cut the linear part
    features = []
    # structure can be a boolean matrix compatible with powers
    if structure is not None:
        assert structure.shape[0] == powers.shape[1]
        nonzero_entries = powers[:, structure] 
    else:
        nonzero_entries = powers
    
    for power in nonzero_entries.T: # transpose to extract columns
        prod = 1
        for i in range(len(power)):
            prod *= y[i,:]**power[i]
        features.append(prod)
    return np.array(features)



def get_matrix(l:list):
    return np.concatenate(l, axis=1)

def generate_exponents(n_features, degree, include_bias = False):
    # generate a dummy set of polynomial features to read off the coefficient matrix
    poly = PolynomialFeatures(degree=degree,
                               include_bias=include_bias).fit(np.ones( (1, n_features) ))
    return poly.powers_.T # gives a matrix of shape (n_features, number of monomials of degree <= degree)



def compute_polynomial_map(coefficients, degree, include_bias = False, skip_linear = False):
    """
    Compute the polynomial map corresponding to the given coefficients
    """
    return lambda x : np.matmul(coefficients,
                                 complex_polynomial_features(x, degree=degree, 
                                                             include_bias = include_bias,
                                                               skip_linear=skip_linear))

def insert_complex_conjugate(x):
    return np.concatenate((x, np.conj(x)), axis = 0)